# GA-Keyboard
遺伝的アルゴリズムっぽいなにかによるキーボード配列の模索

## 備忘録
　開発にあたっての備忘録とかメモをいくつか。   
　これの製作者は遺伝的アルゴリズムや機械学習に関して一切の知識はないものとする。  
　そして、これは、遺伝的アルゴリズムからヒントを得た独自のアルゴリズムになっている。っぽい何かっていうのはこれによるもの。

　以下、キーの配列は断りがない限りQWERTY配列の話をしている。

#### データ構造
　FやJの部分にEが入るのとQやPの部分にEが入るのでは評価に差がある。
ここで簡易的に2次元配列をキーボードのデータ構造とするならば、中心から外へ行くほど(真ん中の二列は例外)`キー単位入力コスト`(後術の評価関数で用いる、キーを押すことに対する評価点)が大きくなっていく。
　今回は、いわゆる「交叉」が私にはいい方法が考えられなかったので、似たようななにかで代用したため、２次元配列でキーボードを表現することにした。そのため上記のような特性を持つことになる。これに関しては、特段気にすることはない。

　またこの配列は上下左右がつながっているものとして、Uの上はMの下はXのようにする。

　記号に関しては、今回は考えないこととする(評価関数用のデータを集めるのに、いろいろな角度から集めないといけないだろうし)。また、空白を交えてキーボードの配列を決定するか、それとも空白は絶対的に固定して、それから配列を決めるかは検討中。

　多分面白そうだし前者を採用するかもね。

#### 評価関数
　英語にとって効率のいい配列を考えるとすると、大量の英単語を入力させ、その入力のコストが低いものを良と考える。  

　評価のコストには大きく分けて2種類あると考える。
キーを入力することそのもののコスト(ここでは`キー単位入力コスト`と呼ぶことにする)と、前のキーからの位置関係によるコスト(ここでは`連続入力コスト`と呼ぶことにする)である。  
　`キー単位入力コスト`は、FやJに比べてAや;が高く、更にそれに比べてQや@のほうが高いものとなる。単純にキー単位でどれだけ入力しづらいかを表すものと考えている。  
　Dvorak配列に習い、ホームポジション(真ん中の一列)のコストは上下の列より全て低いと考えているならば、Aのコスト < Rのコストとなる。  
　そのあたりは個人の趣味であると思うので、適当にしっかり決めるつもりである。

　あと、個人的にBのコストがめちゃくちゃ高い気がするので低めになっている。でもなぜかYは別に高い気はしない。打ち慣れのせいな気もする。そんな気がするためYも低めにする。移動距離多いしね。

　以下コスト一覧。割と雑。やっていくうちに変化があると思う。  
　Dvorak配列を意識するならば、AとRのコスト差を大きくすることでできるかもしれない。

キー | コスト | キー | コスト
-----|--------|------|-------
F    | 1.0    | J    | 1.0
G    | 1.2    | H    | 1.2
D    | 1.5    | K    | 1.5
S    | 1.8    | L    | 1.8
A    | 2.0    | ;    | 2.0
R    | 2.2    | U    | 2.2
V    | 2.2    | M    | 2.2
E    | 2.6    | I    | 2.6
C    | 2.6    | ,    | 2.6
T    | 3.0    | N    | 3.0
W    | 4.0    | O    | 4.0
X    | 4.0    | .    | 4.0
Q    | 4.5    | P    | 4.5
Z    | 4.5    | /    | 4.5
B    | 5.0    | Y    | 5.0

　`連続入力コスト`に関しては、前のキーが4種類の打ちどれかによってコストを振り分けることを考える。その4種類を以下に示す。

　細かいことを言うなら同手別指であれば、前回と今回の指の関係でコストを変える(人差し指と中指だったらコストは低いが、人差し指と小指や薬指と小指などの組み合わせじゃコストは高い気がする)べきとか、考えることはある。

名称     | コスト | 説明
---------|--------|-------------------------------------------------------------------------
交互     | 1.0    | 今回入力するキーを前回入力したキーの反対の手で入力する場合
同手別指 | 3.0    | 今回入力するキーを前回入力したキーと同じ手で入力する場合
同キー   | 4.8    | 今回入力するキーが前回入力したキーと同じ
同手同指 | 5.0    | 今回入力するキーが前回入力したキーと同じ指で入力する場合(同じキーを除く)

#### 遺伝的アルゴリズムの各種操作について

　基本的に, n世代目とn + 1世代目の関係(n > 0)は
- n世代, n + 1世代共に、世代の遺伝子数は定数(50個ぐらい?)
- n + 1世代はルーレット選択による交叉
- 具体的な数値は決めていないが突然変異発生率は収束しなくてもいいので高めに設定
とする。

　突然変異発生率を高くするのは、今回交叉の方法を若干特殊にしたためである。もしかしたら不要になるかもしれない。

##### ルーレット選択方法
　そもそもルーレット選択をどうするのかということだが、今回は「どれだけ自分の優良であると考えられるキーを残せるか」と言うことを重きを置き、一切「自分の優良点と相手の優良点を組み合わせる」ということはない。  
　これはそもそも後術の交叉で一切交叉をしていないことからもわかる。

　ルーレット選択のアルゴリズム(後術の交叉にも関わる)は次のようなものとする

- 通常のルーレット選択のアルゴリズムを用いてどれだけ遺伝子を残すかのパーセンテージを取得する
- その確率を1世代に現れるすべてのキーの数(30キー * 50遺伝子 = 1500)にかけた値(端数切り上げ)が自分が次の世代に残すキーの数
- キーの数が30以上あれば一つまるごとすべて残すということになり、30で割った数のあまりが交叉(笑)で交換しないキーの数である
- 交換しないキーであるが、影響力の大きいキーとして`キー単位入力コスト`が低い、または高いキーを上から順番に選ぶという方式を取る予定。例えば、`キー単位入力コスト`の平均との差の二乗が高いものから選んでいくといった形



##### 交叉らしきもの

　交叉のアルゴリズムは次のようなものとする
- 遺伝子(配列)におけるそれぞれのキー"`key`"に対して以下を行う
  - そのキーがルーレット選択を通して、交換しないキーに含まれる場合何もしない
   一定確率(例えば40%, 通常より大幅に低めがいい気がする)で、以下のいずれかの動作を一つ行う。以下のどれを行うかは同様に確からしい
    - 左側のキーと交換する
    - 右側のキーと交換する
    - 上側のキーと交換する
    - 下側のキーと交換する
    - 中央(TGBとYHNの真ん中)を挟んで線対称となる反対のキーと交換

　交叉と名乗ってはいるが、実は一切交叉はしていないx。もし仮に交叉する場所があったとしても、強いてできるならば「任意の位置のキーが相手の同じ場所のキーと一致しているか」の確認部分だけである。  
　というのも、当然だがキーボードには「同じ種類のキーは必ず一つ」という制約があるから(CtrlとかShiftとか2つありますね、はい論破)。  
　遺伝的アルゴリズムだしそこらへんを気にしないこともできるが、整合性を100%保った状態でさらに低コストになるって期待できそうもないのでやめておく。

　これが、遺伝的アルゴリズム"っぽいなにか"の最もたる所以です。

　ちなみに、交換元がルーレット選択により交換しないキーに含まれる場合は交換しないが、交換先がルーレット選択により交換しないキーに含まれる場合も交換せず何もしないことを選択するようにしてみる。

##### 突然変異

　突然変異のアルゴリズムは次のようなものとする
- 遺伝子(配列)におけるそれぞれのキー"`key`"に対して以下を行う
  - 一定の低確率(といってもそこそこ高め、5%とか?)で、ランダムなキーと交換する
